// =================================================================================
// 1. LIBRARIES
// =================================================================================
#include <WiFi.h>                     // Enables WiFi connectivity (Station mode).
#include <esp_camera.h>               // Driver for the OV2640 camera module.
#include <esp_http_server.h>          // Lightweight web server to serve HTML and JSON.
#include <img_converters.h>           // Utilities to convert Raw Grayscale -> JPEG.
#include <mbedtls/base64.h>           // Encodes binary image data into text for HTML transfer.
#include <TensorFlowLite_ESP32.h>     // The AI Engine optimized for microcontrollers.

// TensorFlow Lite Micro (TFLM) specific headers
#include "tensorflow/lite/micro/all_ops_resolver.h" // Loads all mathematical operations (Conv2D, Softmax, etc).
#include "tensorflow/lite/micro/micro_error_reporter.h" // Handles debug logging for the AI.
#include "tensorflow/lite/micro/micro_interpreter.h"    // The "Brain" that runs the model.

// Our specific neural network model (generated by the Python script)
#include "modelquantized.h" 

// =================================================================================
// 2. SETTINGS
// =================================================================================
const char* ssid = "The Procrastination station"; // Your WiFi Name
const char* pass = "Green42$";                    // Your WiFi Password

// =================================================================================
// 3. GLOBAL VARIABLES FOR AI
// We use globals because allocating these in `loop()` would be slow and fragment memory.
// =================================================================================

// The size of the memory scratchpad for the AI. 
// It needs space for input/output tensors and intermediate calculations.
// 512KB is generous for ESP32-CAM with PSRAM.
const int kArenaSize = 512 * 1024; 

// Labels must match the order of folders in your Python dataset.
const char* CLASSES[] = { "Paper", "Rock", "Scissors" };

uint8_t* tensor_arena = nullptr;             // Pointer to the allocated memory block.
tflite::MicroInterpreter* interpreter = nullptr; // The engine instance.
TfLiteTensor* input = nullptr;               // Pointer to the model's "Input Layer".
TfLiteTensor* output = nullptr;              // Pointer to the model's "Output Layer".

// =================================================================================
// 4. HTML INTERFACE
// Stored in PROGMEM (Flash memory) to save RAM.
// This is a minified webpage containing JavaScript to fetch data from the ESP32.
// =================================================================================
const char index_html[] PROGMEM = R"rawliteral(<!DOCTYPE HTML><html><head><meta name="viewport" content="width=device-width,initial-scale=1"><style>body{text-align:center;font-family:Arial;background:#222;color:#fff}img{width:100%;max-width:300px;border:2px solid #555}#pred{font-size:40px;color:#0f0;margin:10px}#scores{font-size:14px;color:#aaa;font-family:monospace}</style></head><body><h2>ESP32 Neural Cam</h2><img id="photo" src=""><div id="pred">WAITING...</div><div id="scores">Connecting...</div><script>const i=document.getElementById("photo"),p=document.getElementById("pred"),s=document.getElementById("scores");async function u(){try{const r=await fetch('/capture');if(!r.ok)throw 0;const d=await r.json();i.src="data:image/jpeg;base64,"+d.image;p.innerHTML=d.prediction;p.style.color=d.prediction==="???"?"#ff0":"#0f0";s.innerHTML=d.scores}catch(e){s.innerHTML="Retry..."}setTimeout(u,50)}window.onload=u;</script></body></html>)rawliteral";

// =================================================================================
// 5. HELPER: SOFTMAX
// The AI outputs "Logits" (raw numbers like -2.5, 4.1, 0.3).
// Softmax converts these into Probabilities (0% - 100%) that sum up to 1.0.
// =================================================================================
void softmax(float* data, int len) {
  float m = -1e38, sum = 0;
  // 1. Find max value (for numerical stability to prevent overflow)
  for(int i=0; i<len; i++) if(data[i]>m) m=data[i];
  // 2. Exponentiate and sum
  for(int i=0; i<len; i++) sum += (data[i] = exp(data[i]-m));
  // 3. Normalize
  for(int i=0; i<len; i++) data[i] /= sum;
}

// =================================================================================
// 6. MAIN SERVER LOGIC: /capture
// This function runs every time the browser requests a new frame.
// =================================================================================
static esp_err_t capture_handler(httpd_req_t *req) {
  
  // --- A. CAPTURE IMAGE ---
  // Takes a raw photo from the camera buffer.
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) return httpd_resp_send_500(req); // Fail gracefully if camera is busy/broken

  // --- B. PRE-PROCESSING & INFERENCE ---
  
  // 1. Normalize: The camera gives 0-255 (integers). The AI was trained on 0.0-1.0 (floats).
  // We divide by 255 (multiplying by 1/255 is faster).
  // Note: 96*96 = 9216 pixels.
  for (int i = 0; i < 9216; i++) {
      input->data.f[i] = fb->buf[i] * 0.003921569f; 
  }
  
  String pred = "???"; // Default if confidence is too low
  String scores = "";

  // 2. Run the AI (Invoke)
  if (interpreter->Invoke() == kTfLiteOk) {
    
    // 3. Process Results
    softmax(output->data.f, 3); // Convert raw numbers to percentages
    
    float max_s = 0; 
    int max_i = -1;

    // Loop through all classes (Paper, Rock, Scissors)
    for (int i = 0; i < 3; i++) {
      float s = output->data.f[i];
      scores += String(CLASSES[i]) + ":" + String((int)(s*100)) + "% "; // Build score string
      
      // Check if this class is the winner
      if (s > max_s) { max_s = s; max_i = i; }
    }
    
    // Threshold: Only claim a match if accuracy > 85%
    if (max_s > 0.85) pred = CLASSES[max_i];
  }

  // --- C. IMAGE COMPRESSION ---
  // The raw image is huge (Grayscale raw bytes). Browsers need JPEG.
  uint8_t *jpg_buf = NULL; 
  size_t jpg_len = 0;
  
  // frame2jpg converts raw framebuffer -> JPEG buffer
  // quality=80 (Lower quality = faster & smaller)
  frame2jpg(fb, 80, &jpg_buf, &jpg_len);
  
  // Important: Release the camera framebuffer so it can take the next photo
  esp_camera_fb_return(fb);

  // --- D. BASE64 ENCODING ---
  // JSON cannot handle binary data. We convert binary JPEG to text (Base64).
  // Formula for Base64 size: 4 * (Length / 3)
  size_t b64_len = ((jpg_len + 2) / 3) * 4 + 1;
  unsigned char* b64_buf = (unsigned char*)malloc(b64_len); // Allocate memory
  size_t out_len = 0;
  
  mbedtls_base64_encode(b64_buf, b64_len, &out_len, jpg_buf, jpg_len);
  b64_buf[out_len] = 0; // Null-terminate string
  free(jpg_buf); // We don't need the JPEG buffer anymore, only the Base64 one

  // --- E. SEND RESPONSE ---
  // We send the data in chunks to avoid creating one massive string that crashes the ESP32.
  httpd_resp_set_type(req, "application/json");
  
  char chunk[128];
  // Create JSON header: { "prediction": "Rock", "scores": "...", "image": "
  snprintf(chunk, sizeof(chunk), "{ \"prediction\": \"%s\", \"scores\": \"%s\", \"image\": \"", pred.c_str(), scores.c_str());
  httpd_resp_send_chunk(req, chunk, strlen(chunk));
  
  // Send the huge image string
  httpd_resp_send_chunk(req, (char*)b64_buf, out_len);
  
  // Close the JSON: " }
  httpd_resp_send_chunk(req, "\" }", 3);
  
  // End response
  httpd_resp_send_chunk(req, NULL, 0);

  free(b64_buf); // Clean up memory
  return ESP_OK;
}

// =================================================================================
// 7. SETUP
// =================================================================================
void setup() {
  // Boost CPU to 240MHz for faster AI inference
  setCpuFrequencyMhz(240);
  Serial.begin(115200);

  // --- CAMERA CONFIGURATION ---
  // These pins correspond to the "AI Thinker ESP32-CAM" board.
  camera_config_t config = {
    .pin_pwdn = 32, .pin_reset = -1, .pin_xclk = 0, .pin_sscb_sda = 26, .pin_sscb_scl = 27,
    .pin_d7 = 35, .pin_d6 = 34, .pin_d5 = 39, .pin_d4 = 36, .pin_d3 = 21, .pin_d2 = 19, .pin_d1 = 18, .pin_d0 = 5,
    .pin_vsync = 25, .pin_href = 23, .pin_pclk = 22,
    .xclk_freq_hz = 20000000, 
    .ledc_timer = LEDC_TIMER_0, .ledc_channel = LEDC_CHANNEL_0,
    .pixel_format = PIXFORMAT_GRAYSCALE, // Crucial: AI expects Gray, not Color
    .frame_size = FRAMESIZE_96X96,       // Crucial: Must match AI input size
    .jpeg_quality = 12, 
    .fb_count = 1                        // Use 1 buffer to save RAM
  };
  esp_camera_init(&config);

  // --- WIFI CONNECTION ---
  WiFi.begin(ssid, pass);
  while (WiFi.status() != WL_CONNECTED) delay(500);
  Serial.print("Camera Ready! Go to: http://"); Serial.println(WiFi.localIP());

  // --- TFLITE INITIALIZATION ---
  // Allocate memory in PSRAM (External RAM) because internal RAM is too small for this.
  // MALLOC_CAP_SPIRAM tells ESP32 to look at the external 4MB chip.
  tensor_arena = (uint8_t*)heap_caps_malloc(kArenaSize, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
  
  static tflite::MicroErrorReporter err_rep; // Logger
  static tflite::AllOpsResolver resolver;    // Operations loader
  
  // Create the Interpreter
  static tflite::MicroInterpreter static_interpreter(
      tflite::GetModel(g_model), // Load model from header file
      resolver, 
      tensor_arena, 
      kArenaSize, 
      &err_rep
  );
  interpreter = &static_interpreter;

  // Ask TFLite to plan memory usage for tensors
  interpreter->AllocateTensors();
  
  // Get shortcuts to the Input and Output buffers for fast access in the loop
  input = interpreter->input(0);
  output = interpreter->output(0);

  // --- WEB SERVER START ---
  httpd_handle_t server = NULL;
  httpd_config_t hconf = HTTPD_DEFAULT_CONFIG();
  httpd_start(&server, &hconf);
  
  // Define URL: "/" -> Shows the HTML page
  httpd_uri_t uri_idx = { "/", HTTP_GET, [](httpd_req_t *r){ 
      httpd_resp_send(r, index_html, HTTPD_RESP_USE_STRLEN); return ESP_OK; 
  }, NULL };
  
  // Define URL: "/capture" -> Runs the AI and returns JSON
  httpd_uri_t uri_cap = { "/capture", HTTP_GET, capture_handler, NULL };
  
  httpd_register_uri_handler(server, &uri_idx);
  httpd_register_uri_handler(server, &uri_cap);
}

// =================================================================================
// 8. LOOP
// =================================================================================
void loop() { 
  // We don't need to do anything here!
  // The 'httpd' server runs in a separate background task (FreeRTOS task).
  // It listens for requests and calls 'capture_handler' automatically.
  delay(10000); 
}